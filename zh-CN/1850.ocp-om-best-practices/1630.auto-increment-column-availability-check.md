# 自增列可用性检查

本节为您介绍如何对集群的自增列可用性进行检查。

## 应用场景

该巡检项检查已有的全局自增列是否够用。

## 前提条件

无。

## 技术原理

OceanBase 作为分布式数据库，表通常分布在多台不同的机器，在尽可能和 MySQL 兼容的同时需要保证分布式多机的自增列生成性能，从而出现了自增值生成过程中的跳变。

在 OceanBase V4.x 版本中，存在两种自增模式（`AUTO_INCREMENT_MODE`）的自增列表，分别为 `ORDER` 模式和 `NOORDER` 模式，默认为 `ORDER` 模式。您可使用 `show create table` 查看包含自增列表的自增模式:

```sql
CREATE TABLE `T1` (
  `c1` int(11) NOT NULL AUTO_INCREMENT,
  `c2` smallint(6) DEFAULT NULL,
  PRIMARY KEY (`c1`)
) AUTO_INCREMENT = 1 AUTO_INCREMENT_MODE = 'ORDER'
```

在 OceanBase V4.x 指定 `AUTO_INCREMENT_MODE = 'NOORDER'` 和 OceanBase V4.0 以下版本创建的包含自增列的表，都是 `NORDER` 模式的自增表。OceanBase V4.x 新增了 `ORDER` 模式的自增列，并且为建表的默认模式，更好地兼容了 MySQL 行为。

## 操作步骤

当巡检发现自增列异常增长（表现为很快突破阈值），需要针对上述两种自增列模式进行排查。不同模式下存在多种自增列场景，您可根据具体场景排查问题根因并进行解决：

* **NORDER**

  * **场景 1: 机器重启或宕机**

      `ORDER` 模式在 leader 节点维护了内存下的缓存区间，当 leader 节点发生重启或宕机时，该区间内未使用的自增值不会被继续使用，从而发生跳变。

      <main id="notice" type='notice'>
      <h4>注意</h4>
      <p>这里跳变的场景仅发生在 leader 节点，其它 follower 节点由于不保存缓存，即使宕机也不会影响自增值的生成连续性。</p>
      </main>

  * **场景 2: 切主**

      当发生切主时，为了避免来回切主从而导致的自增值不递增问题：
        1. 比如 OBServer2 起始缓存为 [1，100] 生成 1，2。
        2. 切主到 OBServer1，OBServer1 得到新的缓存区间 [101，200] 生成 101，102。
        3. 再次切回 OBServer2，继续复用上一次的缓存，得到 3，4，从 101 到 3 发生了不递增的问题。

* **ORDER**

  * **场景 1: 多机多分区生成自增值**

      假设 `auto_increment_cache_size` 为 100，举例说明当分区表存在的 OBServer1、OBServer2、OBServer3 分别均匀接收到 `insert into values (null)` 请求时，它们的行为：
        1. OBServer1 发现自身没有缓存时，向内部表申请一段自增区间 [1, 100]，并且生成一个自增值 1。
        2. OBServer2 发现自身没有缓存时，向内部表申请一段自增区间 [101, 200]，并且生成一个自增值 101。
        3. OBServer3 发现自身没有缓存时，向内部表申请一段自增区间 [201, 300]，并且生成一个自增值 201。
        4. OBServer1 使用缓存 [2，100] 生成自增值 2。
        5. OBServer2 使用缓存 [102，200] 生成自增值 102。
        6. ...

      这样表内的插入数据顺序为 1，101，201，2，102，... 可以发现自增值总是在发生跳变。

  * **场景 2: INSERT 插入指定最大值**

      在 MySQL 的行为中，如果显式往自增列插入指定值，那么后续生成的自增值都不会小于该值。

      在 OceanBase 的分布式场景下，不光需要 OBServer 本身知道当前插入了一个最大值，还需要同步给其它 server 和内部表，这个同步动作十分耗时，为了避免每次指定最大值时都做同步操作，会在 insert 一个最大值时放弃掉当前的缓存，这样从当前值开始到下一个缓存值前都不需要进行同步。

      当分区表存在的 OBServer1、OBServer2、OBServer3 分别均匀接收到显式指定递增序列 (1, 2, 3, ...) 请求时，并且假设它们原始都存在缓存的行为：

      1. OBServer1 接收到 1，放弃掉缓存 [1，100]，重新从内部表获取到一段新的缓存区间 [301，400]，并且把 101 作为一个 sync 值同步到内部表和其它 OBServer。
      2. OBServer2 接收到 2，发现比当前的缓存区间小 [101，200]，不做操作。
      3. OBServer3 接收到 3，发现比当前的缓存区间小 [201，300]，不做操作。
      4. OBServer1 接收到 4，发现比当前的缓存区间小 [301，400]，不做操作。
      5. ...

      这样如果插入部分值后继续使用自增列生成序列，就会发生跳变，比如 OBServer1 第一个区间 [1，100] 都没有使用而是直接跳到了 301，该问题单机场景也会出现：

      ```sql
      obclient> create table t1 (c1 int not null auto_increment);
      obclient> insert into t1 values (null);
      obclient> insert into t1 values (3);
      obclient> insert into t1 values (null);
      obclient> select * from t1;
      +-----+
      | c1  |
      +-----+
      |   1 |
      |   3 |
      | 104 | -- 跳变一个cache size大小
      +-----+
      3 rows in set (0.05 sec)
      ```

  * **场景 3: 机器重启或宕机**

      自增列缓存是一个内存结构，如果 OBServer 发生了重启或宕机，这部分未使用完的区间不会写回内部表，导致这部分区间不会再被使用，比如 OBServer1 初始自增列缓存区间为 [1，100]，并且已经生成了 1，2，此时发生了宕机，重启后变成了新的区间 [101，200]，下一次的自增值为 101，序列 1，2，101，... 发生了跳变。

  * **场景 4: 切主**

      在 OceanBase V4.0 以下版本中，自增列不保证连续，但是需要保证分区内递增，为了保证这个行为，每次切主时会放弃掉当前的缓存区间，从而出现类似机器重启的自增值跳跃行为，此处不再赘述。
